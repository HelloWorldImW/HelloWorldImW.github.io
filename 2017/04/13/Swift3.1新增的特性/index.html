

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Joe">
  <meta name="keywords" content="undefined">
  
    <meta name="description" content="Apple最近发布了Xcode8.3, 以及Swift的一个小版本3.1。 不过不要担心, Swift3.1和Swift3是兼容的,这不会给你的Swift3项目造成太多的麻烦。不幸的是, Xcode8.3无情的去掉了对Swift2.3的支持, 所以, 如果你的项目在使用3.0之前的版本，个人建议还是不要着急更新。  数值类型的failable initialize这个改动, 来自于SE-0080">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift3.1新增的特性">
<meta property="og:url" content="https://zhihaoo.wang/2017/04/13/Swift3.1%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="至皓君的Blog">
<meta property="og:description" content="Apple最近发布了Xcode8.3, 以及Swift的一个小版本3.1。 不过不要担心, Swift3.1和Swift3是兼容的,这不会给你的Swift3项目造成太多的麻烦。不幸的是, Xcode8.3无情的去掉了对Swift2.3的支持, 所以, 如果你的项目在使用3.0之前的版本，个人建议还是不要着急更新。  数值类型的failable initialize这个改动, 来自于SE-0080">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-04-13T23:03:25.000Z">
<meta property="article:modified_time" content="2025-06-20T06:54:09.061Z">
<meta property="article:author" content="Joe">
<meta property="article:tag" content="Swift">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Swift3.1新增的特性 - 至皓君的Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zhihaoo.wang","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="至皓君的Blog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>至皓君的Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Swift3.1新增的特性"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2017-04-13 23:03" pubdate>
          2017年4月13日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          2.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          19 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Swift3.1新增的特性</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>Apple最近发布了Xcode8.3, 以及Swift的一个小版本3.1。 不过不要担心, Swift3.1和Swift3是兼容的,这不会给你的Swift3项目造成太多的麻烦。不幸的是, Xcode8.3无情的去掉了对Swift2.3的支持, 所以, 如果你的项目在使用3.0之前的版本，个人建议还是不要着急更新。</p>
</blockquote>
<h2 id="数值类型的failable-initialize"><a href="#数值类型的failable-initialize" class="headerlink" title="数值类型的failable initialize"></a>数值类型的failable initialize</h2><p>这个改动, 来自于<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0080-failable-numeric-initializers.md">SE-0080</a>。Swift为所有的数字类型定义了<code>failable initializer</code>, 当构造失败的时候, 就会返回<code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Add</span> a new family of numeric conversion initializers with the following signatures to all numeric types:<br><span class="hljs-comment">//  Conversions from all integer types.</span><br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">Int8</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">Int16</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">Int32</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">Int64</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">Int</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">UInt8</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">UInt16</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">UInt32</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">UInt64</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">UInt</span>)<br><br><span class="hljs-comment">//  Conversions from all floating-point types.</span><br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">Float</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">Double</span>)<br><span class="hljs-keyword">#if</span> arch(i386) <span class="hljs-operator">||</span> arch(x86_64)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">Float80</span>)<br><span class="hljs-keyword">#endif</span><br></code></pre></td></tr></table></figure>
<p>OK, 再让我们更直观的感受一下这个方法:</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-comment">/// 行尾注释为运行结果</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">1.11</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-built_in">Int</span>(a)          <span class="hljs-comment">//!&lt; 1</span><br><span class="hljs-keyword">let</span> c = <span class="hljs-built_in">Int</span>(exactly: a) <span class="hljs-comment">//!&lt; nil</span><br><br><span class="hljs-keyword">let</span> d = <span class="hljs-number">1.0</span><br><span class="hljs-keyword">let</span> e = <span class="hljs-built_in">Int</span>(exactly: d) <span class="hljs-comment">//!&lt; 1</span><br></code></pre></td></tr></table></figure>
<p>在上面这段代码中, 我们可以看到<code>1.11 -&gt; Int(exactly:) -&gt; c</code>的结果为<code>nil</code>, 而<code>1.0 -&gt; Int() -&gt; e</code>的结果却是成功的。其实不难发现, <code>Int(exactly:)</code>比<code>Int()</code>的精度检查更加严格, 不会允许精度丢失的情况。因此<code>Int(exactly:)</code>转化时,如果丢失精度, 会返回nil。</p>
<p>为什么要加这个特性呢？或者说这个特性的应用场景是什么呢？SE中是这么说的:</p>
<blockquote>
<p>It is extremely common to receive loosely typed data from an external source such as json. This data usually has an expected schema with more precise types. When initializing model objects with such data runtime conversion must be performed. It is extremely desirable to be able to do so in a safe and recoverable manner. The best way to accomplish that is to support failable numeric conversions in the standard library.</p>
</blockquote>
<p>这段话的大体意思就是，如果你要把一个类似Any这样的松散类型转换成数字类型的时候，像服务端返回的json数据，这个特性就会提现他的价值了。</p>
<h2 id="Sequence中新添加的两个筛选元素的方法"><a href="#Sequence中新添加的两个筛选元素的方法" class="headerlink" title="Sequence中新添加的两个筛选元素的方法"></a>Sequence中新添加的两个筛选元素的方法</h2><p>这个特性是根据<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0045-scan-takewhile-dropwhile.md">SE-0045</a>改动的。初步意愿如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Modify</span> the declaration of <span class="hljs-type">Sequence</span> with two new members:<br><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Sequence</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">/// Returns a subsequence by skipping elements while `predicate` returns</span><br>  <span class="hljs-comment">/// `true` and returning the remainder.</span><br>  <span class="hljs-keyword">func</span> <span class="hljs-title function_">drop</span>(<span class="hljs-params">while</span> <span class="hljs-params">predicate</span>: (<span class="hljs-keyword">Self</span>.<span class="hljs-type">Iterator</span>.<span class="hljs-type">Element</span>) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Bool</span>) <span class="hljs-keyword">rethrows</span> -&gt; <span class="hljs-keyword">Self</span>.<span class="hljs-type">SubSequence</span><br>  <span class="hljs-comment">/// Returns a subsequence containing the initial elements until `predicate`</span><br>  <span class="hljs-comment">/// returns `false` and skipping the remainder.</span><br>  <span class="hljs-keyword">func</span> <span class="hljs-title function_">prefix</span>(<span class="hljs-params">while</span> <span class="hljs-params">predicate</span>: (<span class="hljs-keyword">Self</span>.<span class="hljs-type">Iterator</span>.<span class="hljs-type">Element</span>) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Bool</span>) <span class="hljs-keyword">rethrows</span> -&gt; <span class="hljs-keyword">Self</span>.<span class="hljs-type">SubSequence</span><br>&#125;<br><span class="hljs-type">Also</span> provide <span class="hljs-keyword">default</span> implementations on <span class="hljs-type">Sequence</span> that <span class="hljs-keyword">return</span> <span class="hljs-type">AnySequence</span>, and <span class="hljs-keyword">default</span> implementations on <span class="hljs-type">Collection</span> that <span class="hljs-keyword">return</span> a slice.<br><br><span class="hljs-type">LazySequenceProtocol</span> and <span class="hljs-type">LazyCollectionProtocol</span> will also be extended with implementations of drop(while:) and <span class="hljs-keyword">prefix</span>(while:) that <span class="hljs-keyword">return</span> <span class="hljs-keyword">lazy</span> sequence<span class="hljs-operator">/</span>collection types. <span class="hljs-type">Like</span> the <span class="hljs-keyword">lazy</span> filter(<span class="hljs-keyword">_</span>:), drop(while:) will perform the filtering when startIndex <span class="hljs-keyword">is</span> accessed.<br></code></pre></td></tr></table></figure><br>所添加的两个新方法如下:</p>
<ul>
<li><code>prefix(while:)</code>：从第一个元素开始，将符合<code>while</code>条件的元素添加进数组A，如果<code>while</code>条件不被满足，则终止判断，并返回数组A。</li>
<li><code>drop(while:)</code>：从第一个元素开始，跳过符合<code>while</code>条件的元素，如果<code>while</code>条件不被满足，则终止判断，并将剩余的元素装进数组返回。</li>
</ul>
<p>具体看下面代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let arr = <span class="hljs-selector-attr">[<span class="hljs-string">&quot;ab&quot;</span>,<span class="hljs-string">&quot;ac&quot;</span>,<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;ba&quot;</span>,<span class="hljs-string">&quot;bc&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>]</span><br><br>let <span class="hljs-selector-tag">a</span> = arr.prefix&#123;$<span class="hljs-number">0</span><span class="hljs-selector-class">.hasPrefix</span>(<span class="hljs-string">&quot;a&quot;</span>)&#125;<br>let <span class="hljs-selector-tag">b</span> = arr.prefix&#123;$<span class="hljs-number">0</span><span class="hljs-selector-class">.hasPrefix</span>(<span class="hljs-string">&quot;b&quot;</span>)&#125;<br>let c = arr<span class="hljs-selector-class">.drop</span> &#123;$<span class="hljs-number">0</span><span class="hljs-selector-class">.hasPrefix</span>(<span class="hljs-string">&quot;a&quot;</span>)&#125;<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a)</span></span> <span class="hljs-comment">//!&lt; [&quot;ab&quot;, &quot;ac&quot;, &quot;aa&quot;]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(b)</span></span> <span class="hljs-comment">//!&lt; []</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(c)</span></span> <span class="hljs-comment">//!&lt; [&quot;ba&quot;, &quot;bc&quot;, &quot;bb&quot;]</span><br></code></pre></td></tr></table></figure><br>可以看到，<code>a</code>打印出了<code>[&quot;ab&quot;, &quot;ac&quot;, &quot;aa&quot;]</code>，<code>arr</code>中第0，1，2个元素都满足while条件，但是第3个元素开始不满足条件，所以，<code>a</code>收到的赋值是第0，1，2三个元素的一个数组。<code>b</code>打印的是一个<code>[]</code>，因为<code>arr</code>中的第一个元素就不满足<code>while</code>的条件，所以判断直接终止，返回一个空数组。</p>
<p><code>c</code>打印出了<code>[&quot;ba&quot;, &quot;bc&quot;, &quot;bb&quot;]</code>，因为<code>arr</code>中的第0，1，2个元素都满足<code>while</code>条件，前缀包含<code>a</code>，所以都被跳过，到第3个元素的时候，<code>ba</code>的前缀并不是<code>a</code>，所以第3个元素之后的所有元素<code>&quot;ba&quot;, &quot;bc&quot;, &quot;bb&quot;</code>都被装进数组返回。</p>
<h2 id="通过available约束Swift版本"><a href="#通过available约束Swift版本" class="headerlink" title="通过available约束Swift版本"></a>通过available约束Swift版本</h2><p>之前版本的swift语言，如果你要控制不同版本里面的API，可能需要像下面这样声明：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> swift(&gt;=3.1)</span><br>    <span class="hljs-function">func <span class="hljs-title">test</span>()</span> &#123;&#125;<br><span class="hljs-meta">#elseif swift(&gt;=3.0)</span><br>    <span class="hljs-function">func <span class="hljs-title">test1</span>()</span> &#123;&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><br><code>#if</code>是通过编译器处理的，也就是说编译器要为每一个<code>if</code>条件独立编译一遍。也就是说如果我们的方法要在<code>Swift3.0</code> 和 <code>3.1</code>可用，那么编译器就得编译两遍。<br>这当然不是一个好的方法。一个更好的办法，应该是只编译一次，然后在生成的程序库包含每个API可以支持的Swift版本。</p>
<p>为此，在<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0141-available-by-swift-version.md">SE-0141</a>中，Swift对@available进行了扩展，现在它不仅可以用于限定操作系统，也可以用来区分Swift版本号了。</p>
<p>首先，为了表示某个API从特定版本之后才可用，可以这样：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">@available</span>(<span class="hljs-keyword">swift</span> <span class="hljs-number">3.1</span>)<br><span class="hljs-keyword">func</span> <span class="hljs-title function_">test</span>() &#123;&#125;<br></code></pre></td></tr></table></figure><br>其次，为了表示某个API可用的版本区间，可以这样：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">@available</span>(<span class="hljs-keyword">swift</span>, introduced: <span class="hljs-number">3.0</span>, obsoleted: <span class="hljs-number">3.1</span>)<br><span class="hljs-keyword">func</span> <span class="hljs-title function_">test</span>() &#123;&#125;<br></code></pre></td></tr></table></figure></p>
<h2 id="使用具体类型在extension中约束泛型参数"><a href="#使用具体类型在extension中约束泛型参数" class="headerlink" title="使用具体类型在extension中约束泛型参数"></a>使用具体类型在extension中约束泛型参数</h2><p>在<code>Swift3.1</code>之前的版本中，如果想要在<code>Int?</code>类型添加一个方法的话，可能需要这样做：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">IntValue</span> &#123;<br>    <span class="hljs-keyword">var</span> value: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br> <br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Int</span>: <span class="hljs-title class_ inherited__">IntValue</span> &#123;<br>    <span class="hljs-keyword">var</span> value: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span> &#125;<br>&#125;<br> <br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Optional</span> <span class="hljs-keyword">where</span> <span class="hljs-type">Wrapped</span>: <span class="hljs-type">IntValue</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">lessThanThree</span>() -&gt; <span class="hljs-type">Bool</span> &#123;<br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> num <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.value <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">&lt;</span> <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>声明了一个协议，给Int写了一个扩展，就是为了给<code>Int?</code>添加<code>lessThanThree()</code>方法，很明显，这不是一个好的解决方法。</p>
<p>在<code>Swift 3.1</code>里，我们有更优雅的实现方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Optional</span> <span class="hljs-keyword">where</span> <span class="hljs-type">Wrapped</span> <span class="hljs-operator">==</span> <span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">lessThanThree</span>() -&gt; <span class="hljs-type">Bool</span> &#123;<br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> num <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">&lt;</span> <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h2 id="临时转换成可逃逸的closure"><a href="#临时转换成可逃逸的closure" class="headerlink" title="临时转换成可逃逸的closure"></a>临时转换成可逃逸的closure</h2><p>在<code>Swift3.0</code>函数的<code>closure</code>类型参数默认从<code>escaping</code>变成了<code>non-escaping</code>。这很好理解，因为大多数用于函数式编程的<code>closure</code>参数的确都以<code>non-escaping</code>的方式工作。</p>
<p>但这样也遇到了一个问题，就是有时候，我们需要把<code>non-escaping</code>属性的<code>closure</code>，传递给需要<code>escaping</code>属性<code>closure</code>的函数。来看个例子：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">func subValue<span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">in</span> array: [Int], <span class="hljs-keyword">with</span>: () -&gt; Int)</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">let</span> <span class="hljs-title">subArray</span> = <span class="hljs-title">array</span>.<span class="hljs-title">lazy</span>.<span class="hljs-title">map</span> &#123; <span class="hljs-title">$0</span> - <span class="hljs-title">with</span><span class="hljs-params">()</span> &#125;</span><br><span class="hljs-function">    <span class="hljs-title">print</span><span class="hljs-params">(subArray[<span class="hljs-number">0</span>])</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><br>注意，上面代码是不能编译通过的。因为<code>lazy.map()</code>是<code>escaping closure</code>，而<code>with()</code>是默认的<code>non-escaping closure</code>。如果根据编译器的指引，我们可能会在<code>with:</code>的后面添加<code>@escaping</code>：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">func subValue<span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">in</span> array: [Int], <span class="hljs-keyword">with</span>:@escaping () -&gt; Int)</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">let</span> <span class="hljs-title">subArray</span> = <span class="hljs-title">array</span>.<span class="hljs-title">lazy</span>.<span class="hljs-title">map</span> &#123; <span class="hljs-title">$0</span> + <span class="hljs-title">with</span><span class="hljs-params">()</span> &#125;</span><br><span class="hljs-function">    <span class="hljs-title">print</span><span class="hljs-params">(subArray[<span class="hljs-number">0</span>])</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><br>这很明显不是我们想要的设计。幸运的是，<code>Swift3.1</code>给出了一个临时转换的方法：<code>withoutActuallyEscaping()</code>，我们的方法可以改写成下面这样：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">func subValue<span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">in</span> array: [Int], <span class="hljs-keyword">with</span>: () -&gt; Int)</span> &#123;</span><br><span class="hljs-function">   <span class="hljs-title">withoutActuallyEscaping</span><span class="hljs-params">(<span class="hljs-keyword">with</span>)</span> &#123; <span class="hljs-params">(escapingWith)</span> <span class="hljs-title">in</span></span><br><span class="hljs-function">       <span class="hljs-title">let</span> <span class="hljs-title">subArray</span> = <span class="hljs-title">array</span>.<span class="hljs-title">lazy</span>.<span class="hljs-title">map</span> &#123; <span class="hljs-title">$0</span> + <span class="hljs-title">escapingWith</span><span class="hljs-params">()</span> &#125;</span><br><span class="hljs-function">       <span class="hljs-title">print</span><span class="hljs-params">(subArray[<span class="hljs-number">0</span>])</span></span><br><span class="hljs-function">   &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><br><code>withoutActuallyEscaping</code>有两个参数，第一个参数表示转换前的<code>non-escaping closure</code>，第二参数也是一个<code>closure</code>，用来执行需要<code>escaping closure</code>的代码，它也有一个参数，就是转换后的<code>closure</code>。因此，在我们的例子里，<code>escapingWith</code>就是转换后的<code>with</code>。</p>
<p>顺带说一句，这里面使用了<code>array.lazy.map()</code>而不是<code>array.map()</code>，是因为<code>array.lazy.map()</code>会延迟实现的时间，并且按需加载，上面的例子中，只有<code>print(subArray[0])</code>使用了一次<code>subArray</code>,所以闭包里的代码只会执行一次。而用<code>array.map()</code>则会遍历整个数组，具体的差异大家自己code试验吧。</p>
<h2 id="关于内嵌类型的两种改进"><a href="#关于内嵌类型的两种改进" class="headerlink" title="关于内嵌类型的两种改进"></a>关于内嵌类型的两种改进</h2><p>在<code>Swift 3.1</code>里，内嵌类型有了两方面变化：</p>
<ul>
<li>普通类型的内嵌类型可以直接使用其外围类型的泛型参数；</li>
<li>泛型类型的内嵌类型可以拥有和其外围类型完全不同的泛型参数；</li>
</ul>
<p>在之前的版本中，我们实现一个链表中的节点可能需要这样：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        var value: T<br>        init(value: T) &#123;<br>            self.value = value;<br>        &#125;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><br>但这里，就有一个问题了，在<code>A&lt;T&gt;</code>中使用的<code>T</code>和<code>B&lt;T&gt;</code>中的<code>T</code>是同一个类型么？为了避开这种歧义，在<code>Swift 3.1</code>里，我们可以把代码改成这样:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>        var value: T<br>        init(value: T) &#123;<br>            self.value = value<br>        &#125;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><br>这就是内嵌类型的第一个特性，尽管<code>B</code>是一个普通类型，但它可以直接使用<code>A&lt;T&gt;</code>中的泛型参数，此时<code>B.value</code>的类型就是<code>A</code>中元素的类型</p>
<p>接下来，我们再来看一个内嵌类型需要自己独立泛型参数的情况。：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&lt;<span class="hljs-title">U</span>&gt; </span>&#123;<br>        var value: U? = nil<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><br>这就是内嵌类型的第二个改进，内嵌类型可以和其外围类型有不同的泛型参数。这里我们使用了<code>U</code>来表示<code>C.value</code>的类型。其实，即便我们在<code>C</code>中使用<code>T</code>作为泛型符号，在<code>C</code>的定义内部，<code>T</code>也是一个全新的类型，并不是<code>A</code>中<code>T</code>的类型，为了避免歧义，我们最好还是用一个全新的字母，避免给自己带来不必要的麻烦。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢:<br><a href="https://www.hackingwithswift.com/swift3-1">hackingwithswift</a><br><a href="https://boxueio.com/">泊学网</a><br>提供的博客</p>
<p>原创作品，转载请注明出处：<a href="https://zhihaoo.wang">https://zhihaoo.wang</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
  <a href="/categories/iOS%E5%BC%80%E5%8F%91/" class="category-chain-item">iOS开发</a>
  
  

      <span class="category-chain">
        
      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Swift/" class="print-no-link">#Swift</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Swift3.1新增的特性</div>
      <div>https://zhihaoo.wang/2017/04/13/Swift3.1新增的特性/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Joe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2017年4月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/06/03/Unity%E6%89%93%E5%8C%85Flutter/" title="Unity打包Flutter">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Unity打包Flutter</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2016/12/28/Swift%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD/" title="Swift中重写重载构造(初始化)方法">
                        <span class="hidden-mobile">Swift中重写重载构造(初始化)方法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      鲁ICP备2022002916号-2
    </a>
  </span>
  
</div>

  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
