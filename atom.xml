<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>至皓君的Blog</title>
  <icon>https://zhihaoo.wang/images/logo.jpg</icon>
  <subtitle>穷则独善其身，达则兼济天下。</subtitle>
  <link href="https://zhihaoo.wang/atom.xml" rel="self"/>
  
  <link href="https://zhihaoo.wang/"/>
  <updated>2025-06-20T06:54:09.061Z</updated>
  <id>https://zhihaoo.wang/</id>
  
  <author>
    <name>Joe</name>
    <email>sdauwangzh@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity定点数物理引擎</title>
    <link href="https://zhihaoo.wang/2025/06/18/Unity%E5%AE%9A%E7%82%B9%E6%95%B0%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/"/>
    <id>https://zhihaoo.wang/2025/06/18/Unity%E5%AE%9A%E7%82%B9%E6%95%B0%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/</id>
    <published>2025-06-18T10:18:16.000Z</published>
    <updated>2025-06-20T06:54:09.061Z</updated>
    
    
    
    
    <category term="游戏开发" scheme="https://zhihaoo.wang/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="Unity" scheme="https://zhihaoo.wang/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/"/>
    
    
    <category term="Unity" scheme="https://zhihaoo.wang/tags/Unity/"/>
    
    <category term="游戏" scheme="https://zhihaoo.wang/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="物理引擎" scheme="https://zhihaoo.wang/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>UGUI学习-锚点与轴心</title>
    <link href="https://zhihaoo.wang/2025/06/04/UGUI%E5%AD%A6%E4%B9%A0-%E9%94%9A%E7%82%B9%E4%B8%8E%E8%BD%B4%E5%BF%83/"/>
    <id>https://zhihaoo.wang/2025/06/04/UGUI%E5%AD%A6%E4%B9%A0-%E9%94%9A%E7%82%B9%E4%B8%8E%E8%BD%B4%E5%BF%83/</id>
    <published>2025-06-04T18:07:47.000Z</published>
    <updated>2025-06-20T06:54:09.061Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>记一次台球游戏开发</title>
    <link href="https://zhihaoo.wang/2025/06/03/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8F%B0%E7%90%83%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    <id>https://zhihaoo.wang/2025/06/03/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8F%B0%E7%90%83%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</id>
    <published>2025-06-03T10:14:22.000Z</published>
    <updated>2025-06-20T06:54:09.061Z</updated>
    
    
    
    
    <category term="游戏开发" scheme="https://zhihaoo.wang/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="Unity" scheme="https://zhihaoo.wang/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/"/>
    
    
    <category term="Unity" scheme="https://zhihaoo.wang/tags/Unity/"/>
    
    <category term="游戏" scheme="https://zhihaoo.wang/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Unity踩坑记录</title>
    <link href="https://zhihaoo.wang/2025/06/03/Unity%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://zhihaoo.wang/2025/06/03/Unity%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2025-06-03T09:55:01.000Z</published>
    <updated>2025-06-20T06:54:09.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="待填坑"><a href="#待填坑" class="headerlink" title="待填坑"></a>待填坑</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;待填坑&quot;&gt;&lt;a href=&quot;#待填坑&quot; class=&quot;headerlink&quot; title=&quot;待填坑&quot;&gt;&lt;/a&gt;待填坑&lt;/h1&gt;</summary>
      
    
    
    
    <category term="游戏开发" scheme="https://zhihaoo.wang/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="Unity" scheme="https://zhihaoo.wang/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/"/>
    
    
    <category term="踩坑" scheme="https://zhihaoo.wang/tags/%E8%B8%A9%E5%9D%91/"/>
    
    <category term="Unity" scheme="https://zhihaoo.wang/tags/Unity/"/>
    
    <category term="游戏" scheme="https://zhihaoo.wang/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>uniapp踩坑记录</title>
    <link href="https://zhihaoo.wang/2025/06/03/uniapp%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://zhihaoo.wang/2025/06/03/uniapp%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2025-06-03T09:54:17.000Z</published>
    <updated>2025-06-20T06:54:09.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="待填坑"><a href="#待填坑" class="headerlink" title="待填坑"></a>待填坑</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;待填坑&quot;&gt;&lt;a href=&quot;#待填坑&quot; class=&quot;headerlink&quot; title=&quot;待填坑&quot;&gt;&lt;/a&gt;待填坑&lt;/h1&gt;</summary>
      
    
    
    
    <category term="UniApp" scheme="https://zhihaoo.wang/categories/UniApp/"/>
    
    
    <category term="踩坑" scheme="https://zhihaoo.wang/tags/%E8%B8%A9%E5%9D%91/"/>
    
    <category term="Vue" scheme="https://zhihaoo.wang/tags/Vue/"/>
    
    <category term="UniApp" scheme="https://zhihaoo.wang/tags/UniApp/"/>
    
  </entry>
  
  <entry>
    <title>Odoo踩坑记录</title>
    <link href="https://zhihaoo.wang/2025/06/03/Odoo%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://zhihaoo.wang/2025/06/03/Odoo%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2025-06-03T09:54:11.000Z</published>
    <updated>2025-06-20T06:54:09.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="待填坑"><a href="#待填坑" class="headerlink" title="待填坑"></a>待填坑</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;待填坑&quot;&gt;&lt;a href=&quot;#待填坑&quot; class=&quot;headerlink&quot; title=&quot;待填坑&quot;&gt;&lt;/a&gt;待填坑&lt;/h1&gt;</summary>
      
    
    
    
    <category term="Odoo" scheme="https://zhihaoo.wang/categories/Odoo/"/>
    
    
    <category term="踩坑" scheme="https://zhihaoo.wang/tags/%E8%B8%A9%E5%9D%91/"/>
    
    <category term="Odoo" scheme="https://zhihaoo.wang/tags/Odoo/"/>
    
  </entry>
  
  <entry>
    <title>Flutter踩坑记录</title>
    <link href="https://zhihaoo.wang/2025/06/03/Flutter%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://zhihaoo.wang/2025/06/03/Flutter%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2025-06-03T09:54:04.000Z</published>
    <updated>2025-06-20T06:54:09.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="待填坑"><a href="#待填坑" class="headerlink" title="待填坑"></a>待填坑</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;待填坑&quot;&gt;&lt;a href=&quot;#待填坑&quot; class=&quot;headerlink&quot; title=&quot;待填坑&quot;&gt;&lt;/a&gt;待填坑&lt;/h1&gt;</summary>
      
    
    
    
    <category term="客户端开发" scheme="https://zhihaoo.wang/categories/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Flutter" scheme="https://zhihaoo.wang/categories/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/Flutter/"/>
    
    
    <category term="Flutter" scheme="https://zhihaoo.wang/tags/Flutter/"/>
    
    <category term="踩坑" scheme="https://zhihaoo.wang/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>Unity代码热更新实践</title>
    <link href="https://zhihaoo.wang/2025/06/03/Unity%E4%BB%A3%E7%A0%81%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E8%B7%B5/"/>
    <id>https://zhihaoo.wang/2025/06/03/Unity%E4%BB%A3%E7%A0%81%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E8%B7%B5/</id>
    <published>2025-06-03T09:52:59.000Z</published>
    <updated>2025-06-20T06:54:09.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="待填坑"><a href="#待填坑" class="headerlink" title="待填坑"></a>待填坑</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;待填坑&quot;&gt;&lt;a href=&quot;#待填坑&quot; class=&quot;headerlink&quot; title=&quot;待填坑&quot;&gt;&lt;/a&gt;待填坑&lt;/h1&gt;</summary>
      
    
    
    
    <category term="游戏开发" scheme="https://zhihaoo.wang/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="Unity" scheme="https://zhihaoo.wang/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/"/>
    
    
    <category term="Unity" scheme="https://zhihaoo.wang/tags/Unity/"/>
    
    <category term="游戏" scheme="https://zhihaoo.wang/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="Lua" scheme="https://zhihaoo.wang/tags/Lua/"/>
    
    <category term="热更新" scheme="https://zhihaoo.wang/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Flutter解决原生手势竞争记录</title>
    <link href="https://zhihaoo.wang/2025/06/03/Flutter%E8%A7%A3%E5%86%B3%E5%8E%9F%E7%94%9F%E6%89%8B%E5%8A%BF%E7%AB%9E%E4%BA%89%E8%AE%B0%E5%BD%95/"/>
    <id>https://zhihaoo.wang/2025/06/03/Flutter%E8%A7%A3%E5%86%B3%E5%8E%9F%E7%94%9F%E6%89%8B%E5%8A%BF%E7%AB%9E%E4%BA%89%E8%AE%B0%E5%BD%95/</id>
    <published>2025-06-03T09:51:22.000Z</published>
    <updated>2025-06-20T06:54:09.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="待填坑"><a href="#待填坑" class="headerlink" title="待填坑"></a>待填坑</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;待填坑&quot;&gt;&lt;a href=&quot;#待填坑&quot; class=&quot;headerlink&quot; title=&quot;待填坑&quot;&gt;&lt;/a&gt;待填坑&lt;/h1&gt;</summary>
      
    
    
    
    <category term="客户端开发" scheme="https://zhihaoo.wang/categories/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Flutter" scheme="https://zhihaoo.wang/categories/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/Flutter/"/>
    
    
    <category term="Flutter" scheme="https://zhihaoo.wang/tags/Flutter/"/>
    
    <category term="原生交互" scheme="https://zhihaoo.wang/tags/%E5%8E%9F%E7%94%9F%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>UnityGameFramework食用指南</title>
    <link href="https://zhihaoo.wang/2025/06/03/UnityGameFramework%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://zhihaoo.wang/2025/06/03/UnityGameFramework%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2025-06-03T09:50:34.000Z</published>
    <updated>2025-06-20T06:54:09.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="待填坑"><a href="#待填坑" class="headerlink" title="待填坑"></a>待填坑</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;待填坑&quot;&gt;&lt;a href=&quot;#待填坑&quot; class=&quot;headerlink&quot; title=&quot;待填坑&quot;&gt;&lt;/a&gt;待填坑&lt;/h1&gt;</summary>
      
    
    
    
    <category term="游戏开发" scheme="https://zhihaoo.wang/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="Unity" scheme="https://zhihaoo.wang/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/"/>
    
    <category term="食用指南" scheme="https://zhihaoo.wang/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="Unity" scheme="https://zhihaoo.wang/tags/Unity/"/>
    
    <category term="游戏" scheme="https://zhihaoo.wang/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="GameFramework" scheme="https://zhihaoo.wang/tags/GameFramework/"/>
    
  </entry>
  
  <entry>
    <title>Unity打包Flutter</title>
    <link href="https://zhihaoo.wang/2025/06/03/Unity%E6%89%93%E5%8C%85Flutter/"/>
    <id>https://zhihaoo.wang/2025/06/03/Unity%E6%89%93%E5%8C%85Flutter/</id>
    <published>2025-06-03T09:49:13.000Z</published>
    <updated>2025-06-20T06:54:09.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="待填坑"><a href="#待填坑" class="headerlink" title="待填坑"></a>待填坑</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;待填坑&quot;&gt;&lt;a href=&quot;#待填坑&quot; class=&quot;headerlink&quot; title=&quot;待填坑&quot;&gt;&lt;/a&gt;待填坑&lt;/h1&gt;</summary>
      
    
    
    
    <category term="游戏开发" scheme="https://zhihaoo.wang/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="Unity" scheme="https://zhihaoo.wang/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/"/>
    
    
    <category term="Flutter" scheme="https://zhihaoo.wang/tags/Flutter/"/>
    
    <category term="Unity" scheme="https://zhihaoo.wang/tags/Unity/"/>
    
    <category term="游戏" scheme="https://zhihaoo.wang/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift3.1新增的特性</title>
    <link href="https://zhihaoo.wang/2017/04/13/Swift3.1%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <id>https://zhihaoo.wang/2017/04/13/Swift3.1%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/</id>
    <published>2017-04-13T23:03:25.000Z</published>
    <updated>2025-06-20T06:54:09.061Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Apple最近发布了Xcode8.3, 以及Swift的一个小版本3.1。 不过不要担心, Swift3.1和Swift3是兼容的,这不会给你的Swift3项目造成太多的麻烦。不幸的是, Xcode8.3无情的去掉了对Swift2.3的支持, 所以, 如果你的项目在使用3.0之前的版本，个人建议还是不要着急更新。</p></blockquote><h2 id="数值类型的failable-initialize"><a href="#数值类型的failable-initialize" class="headerlink" title="数值类型的failable initialize"></a>数值类型的failable initialize</h2><p>这个改动, 来自于<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0080-failable-numeric-initializers.md">SE-0080</a>。Swift为所有的数字类型定义了<code>failable initializer</code>, 当构造失败的时候, 就会返回<code>nil</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Add</span> a new family of numeric conversion initializers with the following signatures to all numeric types:<br><span class="hljs-comment">//  Conversions from all integer types.</span><br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">Int8</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">Int16</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">Int32</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">Int64</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">Int</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">UInt8</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">UInt16</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">UInt32</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">UInt64</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">UInt</span>)<br><br><span class="hljs-comment">//  Conversions from all floating-point types.</span><br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">Float</span>)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">Double</span>)<br><span class="hljs-keyword">#if</span> arch(i386) <span class="hljs-operator">||</span> arch(x86_64)<br><span class="hljs-keyword">init?</span>(<span class="hljs-params">exactly</span> <span class="hljs-params">value</span>: <span class="hljs-type">Float80</span>)<br><span class="hljs-keyword">#endif</span><br></code></pre></td></tr></table></figure><p>OK, 再让我们更直观的感受一下这个方法:</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-comment">/// 行尾注释为运行结果</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">1.11</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-built_in">Int</span>(a)          <span class="hljs-comment">//!&lt; 1</span><br><span class="hljs-keyword">let</span> c = <span class="hljs-built_in">Int</span>(exactly: a) <span class="hljs-comment">//!&lt; nil</span><br><br><span class="hljs-keyword">let</span> d = <span class="hljs-number">1.0</span><br><span class="hljs-keyword">let</span> e = <span class="hljs-built_in">Int</span>(exactly: d) <span class="hljs-comment">//!&lt; 1</span><br></code></pre></td></tr></table></figure><p>在上面这段代码中, 我们可以看到<code>1.11 -&gt; Int(exactly:) -&gt; c</code>的结果为<code>nil</code>, 而<code>1.0 -&gt; Int() -&gt; e</code>的结果却是成功的。其实不难发现, <code>Int(exactly:)</code>比<code>Int()</code>的精度检查更加严格, 不会允许精度丢失的情况。因此<code>Int(exactly:)</code>转化时,如果丢失精度, 会返回nil。</p><p>为什么要加这个特性呢？或者说这个特性的应用场景是什么呢？SE中是这么说的:</p><blockquote><p>It is extremely common to receive loosely typed data from an external source such as json. This data usually has an expected schema with more precise types. When initializing model objects with such data runtime conversion must be performed. It is extremely desirable to be able to do so in a safe and recoverable manner. The best way to accomplish that is to support failable numeric conversions in the standard library.</p></blockquote><p>这段话的大体意思就是，如果你要把一个类似Any这样的松散类型转换成数字类型的时候，像服务端返回的json数据，这个特性就会提现他的价值了。</p><h2 id="Sequence中新添加的两个筛选元素的方法"><a href="#Sequence中新添加的两个筛选元素的方法" class="headerlink" title="Sequence中新添加的两个筛选元素的方法"></a>Sequence中新添加的两个筛选元素的方法</h2><p>这个特性是根据<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0045-scan-takewhile-dropwhile.md">SE-0045</a>改动的。初步意愿如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Modify</span> the declaration of <span class="hljs-type">Sequence</span> with two new members:<br><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Sequence</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">/// Returns a subsequence by skipping elements while `predicate` returns</span><br>  <span class="hljs-comment">/// `true` and returning the remainder.</span><br>  <span class="hljs-keyword">func</span> <span class="hljs-title function_">drop</span>(<span class="hljs-params">while</span> <span class="hljs-params">predicate</span>: (<span class="hljs-keyword">Self</span>.<span class="hljs-type">Iterator</span>.<span class="hljs-type">Element</span>) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Bool</span>) <span class="hljs-keyword">rethrows</span> -&gt; <span class="hljs-keyword">Self</span>.<span class="hljs-type">SubSequence</span><br>  <span class="hljs-comment">/// Returns a subsequence containing the initial elements until `predicate`</span><br>  <span class="hljs-comment">/// returns `false` and skipping the remainder.</span><br>  <span class="hljs-keyword">func</span> <span class="hljs-title function_">prefix</span>(<span class="hljs-params">while</span> <span class="hljs-params">predicate</span>: (<span class="hljs-keyword">Self</span>.<span class="hljs-type">Iterator</span>.<span class="hljs-type">Element</span>) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Bool</span>) <span class="hljs-keyword">rethrows</span> -&gt; <span class="hljs-keyword">Self</span>.<span class="hljs-type">SubSequence</span><br>&#125;<br><span class="hljs-type">Also</span> provide <span class="hljs-keyword">default</span> implementations on <span class="hljs-type">Sequence</span> that <span class="hljs-keyword">return</span> <span class="hljs-type">AnySequence</span>, and <span class="hljs-keyword">default</span> implementations on <span class="hljs-type">Collection</span> that <span class="hljs-keyword">return</span> a slice.<br><br><span class="hljs-type">LazySequenceProtocol</span> and <span class="hljs-type">LazyCollectionProtocol</span> will also be extended with implementations of drop(while:) and <span class="hljs-keyword">prefix</span>(while:) that <span class="hljs-keyword">return</span> <span class="hljs-keyword">lazy</span> sequence<span class="hljs-operator">/</span>collection types. <span class="hljs-type">Like</span> the <span class="hljs-keyword">lazy</span> filter(<span class="hljs-keyword">_</span>:), drop(while:) will perform the filtering when startIndex <span class="hljs-keyword">is</span> accessed.<br></code></pre></td></tr></table></figure><br>所添加的两个新方法如下:</p><ul><li><code>prefix(while:)</code>：从第一个元素开始，将符合<code>while</code>条件的元素添加进数组A，如果<code>while</code>条件不被满足，则终止判断，并返回数组A。</li><li><code>drop(while:)</code>：从第一个元素开始，跳过符合<code>while</code>条件的元素，如果<code>while</code>条件不被满足，则终止判断，并将剩余的元素装进数组返回。</li></ul><p>具体看下面代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let arr = <span class="hljs-selector-attr">[<span class="hljs-string">&quot;ab&quot;</span>,<span class="hljs-string">&quot;ac&quot;</span>,<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;ba&quot;</span>,<span class="hljs-string">&quot;bc&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>]</span><br><br>let <span class="hljs-selector-tag">a</span> = arr.prefix&#123;$<span class="hljs-number">0</span><span class="hljs-selector-class">.hasPrefix</span>(<span class="hljs-string">&quot;a&quot;</span>)&#125;<br>let <span class="hljs-selector-tag">b</span> = arr.prefix&#123;$<span class="hljs-number">0</span><span class="hljs-selector-class">.hasPrefix</span>(<span class="hljs-string">&quot;b&quot;</span>)&#125;<br>let c = arr<span class="hljs-selector-class">.drop</span> &#123;$<span class="hljs-number">0</span><span class="hljs-selector-class">.hasPrefix</span>(<span class="hljs-string">&quot;a&quot;</span>)&#125;<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a)</span></span> <span class="hljs-comment">//!&lt; [&quot;ab&quot;, &quot;ac&quot;, &quot;aa&quot;]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(b)</span></span> <span class="hljs-comment">//!&lt; []</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(c)</span></span> <span class="hljs-comment">//!&lt; [&quot;ba&quot;, &quot;bc&quot;, &quot;bb&quot;]</span><br></code></pre></td></tr></table></figure><br>可以看到，<code>a</code>打印出了<code>[&quot;ab&quot;, &quot;ac&quot;, &quot;aa&quot;]</code>，<code>arr</code>中第0，1，2个元素都满足while条件，但是第3个元素开始不满足条件，所以，<code>a</code>收到的赋值是第0，1，2三个元素的一个数组。<code>b</code>打印的是一个<code>[]</code>，因为<code>arr</code>中的第一个元素就不满足<code>while</code>的条件，所以判断直接终止，返回一个空数组。</p><p><code>c</code>打印出了<code>[&quot;ba&quot;, &quot;bc&quot;, &quot;bb&quot;]</code>，因为<code>arr</code>中的第0，1，2个元素都满足<code>while</code>条件，前缀包含<code>a</code>，所以都被跳过，到第3个元素的时候，<code>ba</code>的前缀并不是<code>a</code>，所以第3个元素之后的所有元素<code>&quot;ba&quot;, &quot;bc&quot;, &quot;bb&quot;</code>都被装进数组返回。</p><h2 id="通过available约束Swift版本"><a href="#通过available约束Swift版本" class="headerlink" title="通过available约束Swift版本"></a>通过available约束Swift版本</h2><p>之前版本的swift语言，如果你要控制不同版本里面的API，可能需要像下面这样声明：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> swift(&gt;=3.1)</span><br>    <span class="hljs-function">func <span class="hljs-title">test</span>()</span> &#123;&#125;<br><span class="hljs-meta">#elseif swift(&gt;=3.0)</span><br>    <span class="hljs-function">func <span class="hljs-title">test1</span>()</span> &#123;&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><br><code>#if</code>是通过编译器处理的，也就是说编译器要为每一个<code>if</code>条件独立编译一遍。也就是说如果我们的方法要在<code>Swift3.0</code> 和 <code>3.1</code>可用，那么编译器就得编译两遍。<br>这当然不是一个好的方法。一个更好的办法，应该是只编译一次，然后在生成的程序库包含每个API可以支持的Swift版本。</p><p>为此，在<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0141-available-by-swift-version.md">SE-0141</a>中，Swift对@available进行了扩展，现在它不仅可以用于限定操作系统，也可以用来区分Swift版本号了。</p><p>首先，为了表示某个API从特定版本之后才可用，可以这样：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">@available</span>(<span class="hljs-keyword">swift</span> <span class="hljs-number">3.1</span>)<br><span class="hljs-keyword">func</span> <span class="hljs-title function_">test</span>() &#123;&#125;<br></code></pre></td></tr></table></figure><br>其次，为了表示某个API可用的版本区间，可以这样：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">@available</span>(<span class="hljs-keyword">swift</span>, introduced: <span class="hljs-number">3.0</span>, obsoleted: <span class="hljs-number">3.1</span>)<br><span class="hljs-keyword">func</span> <span class="hljs-title function_">test</span>() &#123;&#125;<br></code></pre></td></tr></table></figure></p><h2 id="使用具体类型在extension中约束泛型参数"><a href="#使用具体类型在extension中约束泛型参数" class="headerlink" title="使用具体类型在extension中约束泛型参数"></a>使用具体类型在extension中约束泛型参数</h2><p>在<code>Swift3.1</code>之前的版本中，如果想要在<code>Int?</code>类型添加一个方法的话，可能需要这样做：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">IntValue</span> &#123;<br>    <span class="hljs-keyword">var</span> value: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br> <br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Int</span>: <span class="hljs-title class_ inherited__">IntValue</span> &#123;<br>    <span class="hljs-keyword">var</span> value: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span> &#125;<br>&#125;<br> <br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Optional</span> <span class="hljs-keyword">where</span> <span class="hljs-type">Wrapped</span>: <span class="hljs-type">IntValue</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">lessThanThree</span>() -&gt; <span class="hljs-type">Bool</span> &#123;<br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> num <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.value <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">&lt;</span> <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>声明了一个协议，给Int写了一个扩展，就是为了给<code>Int?</code>添加<code>lessThanThree()</code>方法，很明显，这不是一个好的解决方法。</p><p>在<code>Swift 3.1</code>里，我们有更优雅的实现方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Optional</span> <span class="hljs-keyword">where</span> <span class="hljs-type">Wrapped</span> <span class="hljs-operator">==</span> <span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">lessThanThree</span>() -&gt; <span class="hljs-type">Bool</span> &#123;<br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> num <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>        <span class="hljs-keyword">return</span> num <span class="hljs-operator">&lt;</span> <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="临时转换成可逃逸的closure"><a href="#临时转换成可逃逸的closure" class="headerlink" title="临时转换成可逃逸的closure"></a>临时转换成可逃逸的closure</h2><p>在<code>Swift3.0</code>函数的<code>closure</code>类型参数默认从<code>escaping</code>变成了<code>non-escaping</code>。这很好理解，因为大多数用于函数式编程的<code>closure</code>参数的确都以<code>non-escaping</code>的方式工作。</p><p>但这样也遇到了一个问题，就是有时候，我们需要把<code>non-escaping</code>属性的<code>closure</code>，传递给需要<code>escaping</code>属性<code>closure</code>的函数。来看个例子：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">func subValue<span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">in</span> array: [Int], <span class="hljs-keyword">with</span>: () -&gt; Int)</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">let</span> <span class="hljs-title">subArray</span> = <span class="hljs-title">array</span>.<span class="hljs-title">lazy</span>.<span class="hljs-title">map</span> &#123; <span class="hljs-title">$0</span> - <span class="hljs-title">with</span><span class="hljs-params">()</span> &#125;</span><br><span class="hljs-function">    <span class="hljs-title">print</span><span class="hljs-params">(subArray[<span class="hljs-number">0</span>])</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><br>注意，上面代码是不能编译通过的。因为<code>lazy.map()</code>是<code>escaping closure</code>，而<code>with()</code>是默认的<code>non-escaping closure</code>。如果根据编译器的指引，我们可能会在<code>with:</code>的后面添加<code>@escaping</code>：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">func subValue<span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">in</span> array: [Int], <span class="hljs-keyword">with</span>:@escaping () -&gt; Int)</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">let</span> <span class="hljs-title">subArray</span> = <span class="hljs-title">array</span>.<span class="hljs-title">lazy</span>.<span class="hljs-title">map</span> &#123; <span class="hljs-title">$0</span> + <span class="hljs-title">with</span><span class="hljs-params">()</span> &#125;</span><br><span class="hljs-function">    <span class="hljs-title">print</span><span class="hljs-params">(subArray[<span class="hljs-number">0</span>])</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><br>这很明显不是我们想要的设计。幸运的是，<code>Swift3.1</code>给出了一个临时转换的方法：<code>withoutActuallyEscaping()</code>，我们的方法可以改写成下面这样：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">func subValue<span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">in</span> array: [Int], <span class="hljs-keyword">with</span>: () -&gt; Int)</span> &#123;</span><br><span class="hljs-function">   <span class="hljs-title">withoutActuallyEscaping</span><span class="hljs-params">(<span class="hljs-keyword">with</span>)</span> &#123; <span class="hljs-params">(escapingWith)</span> <span class="hljs-title">in</span></span><br><span class="hljs-function">       <span class="hljs-title">let</span> <span class="hljs-title">subArray</span> = <span class="hljs-title">array</span>.<span class="hljs-title">lazy</span>.<span class="hljs-title">map</span> &#123; <span class="hljs-title">$0</span> + <span class="hljs-title">escapingWith</span><span class="hljs-params">()</span> &#125;</span><br><span class="hljs-function">       <span class="hljs-title">print</span><span class="hljs-params">(subArray[<span class="hljs-number">0</span>])</span></span><br><span class="hljs-function">   &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><br><code>withoutActuallyEscaping</code>有两个参数，第一个参数表示转换前的<code>non-escaping closure</code>，第二参数也是一个<code>closure</code>，用来执行需要<code>escaping closure</code>的代码，它也有一个参数，就是转换后的<code>closure</code>。因此，在我们的例子里，<code>escapingWith</code>就是转换后的<code>with</code>。</p><p>顺带说一句，这里面使用了<code>array.lazy.map()</code>而不是<code>array.map()</code>，是因为<code>array.lazy.map()</code>会延迟实现的时间，并且按需加载，上面的例子中，只有<code>print(subArray[0])</code>使用了一次<code>subArray</code>,所以闭包里的代码只会执行一次。而用<code>array.map()</code>则会遍历整个数组，具体的差异大家自己code试验吧。</p><h2 id="关于内嵌类型的两种改进"><a href="#关于内嵌类型的两种改进" class="headerlink" title="关于内嵌类型的两种改进"></a>关于内嵌类型的两种改进</h2><p>在<code>Swift 3.1</code>里，内嵌类型有了两方面变化：</p><ul><li>普通类型的内嵌类型可以直接使用其外围类型的泛型参数；</li><li>泛型类型的内嵌类型可以拥有和其外围类型完全不同的泛型参数；</li></ul><p>在之前的版本中，我们实现一个链表中的节点可能需要这样：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        var value: T<br>        init(value: T) &#123;<br>            self.value = value;<br>        &#125;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><br>但这里，就有一个问题了，在<code>A&lt;T&gt;</code>中使用的<code>T</code>和<code>B&lt;T&gt;</code>中的<code>T</code>是同一个类型么？为了避开这种歧义，在<code>Swift 3.1</code>里，我们可以把代码改成这样:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>        var value: T<br>        init(value: T) &#123;<br>            self.value = value<br>        &#125;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><br>这就是内嵌类型的第一个特性，尽管<code>B</code>是一个普通类型，但它可以直接使用<code>A&lt;T&gt;</code>中的泛型参数，此时<code>B.value</code>的类型就是<code>A</code>中元素的类型</p><p>接下来，我们再来看一个内嵌类型需要自己独立泛型参数的情况。：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&lt;<span class="hljs-title">U</span>&gt; </span>&#123;<br>        var value: U? = nil<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><br>这就是内嵌类型的第二个改进，内嵌类型可以和其外围类型有不同的泛型参数。这里我们使用了<code>U</code>来表示<code>C.value</code>的类型。其实，即便我们在<code>C</code>中使用<code>T</code>作为泛型符号，在<code>C</code>的定义内部，<code>T</code>也是一个全新的类型，并不是<code>A</code>中<code>T</code>的类型，为了避免歧义，我们最好还是用一个全新的字母，避免给自己带来不必要的麻烦。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢:<br><a href="https://www.hackingwithswift.com/swift3-1">hackingwithswift</a><br><a href="https://boxueio.com/">泊学网</a><br>提供的博客</p><p>原创作品，转载请注明出处：<a href="https://zhihaoo.wang">https://zhihaoo.wang</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Apple最近发布了Xcode8.3, 以及Swift的一个小版本3.1。 不过不要担心, Swift3.1和Swift3是兼容的,这不会给你的Swift3项目造成太多的麻烦。不幸的是, Xcode8.3无情的去掉了对Swift2.3的支持, 所以</summary>
      
    
    
    
    <category term="iOS开发" scheme="https://zhihaoo.wang/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Swift" scheme="https://zhihaoo.wang/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift中重写重载构造(初始化)方法</title>
    <link href="https://zhihaoo.wang/2016/12/28/Swift%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD/"/>
    <id>https://zhihaoo.wang/2016/12/28/Swift%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD/</id>
    <published>2016-12-28T23:33:32.000Z</published>
    <updated>2025-06-20T06:54:09.061Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>构造方法是一个类创建对象最先也是必须调用的方法, 在OC中, 我们更习惯称这类方法为初始化方法. OC中的初始化方法与普通方法相比,并没有太严格的分界除了要以init开头. 在Swift语言体系中，构造方法与普通的方法分界十分严格，从格式写法上就有不同，普通方法函数要以func声明，构造方法统一为init命名，不需要func关键字声明，不同的构造方法采用方法重载方式创建(<strong><em>在OC中并没有重载的概念,因为OC的一个方法每增加一个参数就会变成另外一个新的方法</em></strong>)。</p></blockquote><h2 id="一、Swift方法的重写与重载"><a href="#一、Swift方法的重写与重载" class="headerlink" title="一、Swift方法的重写与重载"></a>一、Swift方法的重写与重载</h2><h3 id="重写"><a href="#重写" class="headerlink" title="重写:"></a>重写:</h3><p><em>在Swift中，重写父类方法必须需要重写的方法前添加<code>override</code>关键字</em></p><ul><li><strong>定义</strong>: 方法重写顾名思义,就是对一个方法的重新实现.</li><li><strong>示例</strong><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 父类中声明一个方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span>: <span class="hljs-title class_ inherited__">NSObject</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">sayHelloWorld</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello World&quot;</span>) <span class="hljs-comment">//!&lt; 输出 Hello World</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/// 子类中重写父类的方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span>: <span class="hljs-title class_ inherited__">SuperClass</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">sayHelloWorld</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello World I am Wang&quot;</span>) <span class="hljs-comment">//!&lt; 输出 Hello World I am Wang</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法-重载"><a href="#方法-重载" class="headerlink" title="(方法)重载:"></a>(方法)重载:</h3></li><li><strong>定义</strong>:简单来说就是方法名相同,但是参数列表不同. 这样同名不同参的方法之间互相称之为重载方法.</li><li><strong>示例</strong><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 子类中重载父类的方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span>: <span class="hljs-title class_ inherited__">SuperClass</span> &#123;<br><span class="hljs-comment">/// sayHelloWorld(name: &quot;WangZH&quot;)</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">sayHelloWorld</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">super</span>.sayHelloWorld()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello World I am <span class="hljs-subst">\(name)</span>&quot;</span>) <span class="hljs-comment">//!&lt; 输出 Hello World I am WangZH</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、Swift构造方法的重写和重载"><a href="#二、Swift构造方法的重写和重载" class="headerlink" title="二、Swift构造方法的重写和重载"></a>二、Swift构造方法的重写和重载</h2><blockquote><p> Swift中的构造方法分为<strong>Designated</strong>构造方法(指定构造方法)与<strong>Convenience</strong>构造方法(方便构造方法)两类。<strong>Designated</strong>构造方法不加任何修饰关键字，<strong>Convenience</strong>构造方法需要使用<strong>Convenience</strong>关键字进行修饰。简而言之，<strong>Convenience</strong>构造方法就是为了方便使用<strong>Designated</strong>构造方法。</p></blockquote><h3 id="NSObject-子类构造方法的重写与重载"><a href="#NSObject-子类构造方法的重写与重载" class="headerlink" title="NSObject 子类构造方法的重写与重载"></a>NSObject 子类构造方法的重写与重载</h3></li><li>NSObject子类构造方法的重写、重载和正常的方法并没有什么太大的区别，唯一值得注意的是<strong>你要保证，在构造方法完成之前，完成所有成员常量（变量）的构造和赋值，可选值（optional）除外。</strong></li><li>以下代码并没有涉及到成员变量（常量）的初始化赋值<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span>: <span class="hljs-title class_ inherited__">NSObject</span> &#123;<br>    <span class="hljs-comment">/// 重写父类init()方法</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() &#123;<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Say Hello&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subclass</span>: <span class="hljs-title class_ inherited__">SuperClass</span> &#123;<br>    <span class="hljs-comment">/// 重载父类的init()方法</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">word</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(name)</span> Say <span class="hljs-subst">\(word)</span>&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-comment">/// 创建便利初始化方法，调用了self.init(name: String, word: String)方法</span><br>    <span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">word</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(name: <span class="hljs-string">&quot;WangZH&quot;</span>, word: word)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在子类的构造方法中改变父类的变量值<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span>: <span class="hljs-title class_ inherited__">NSObject</span> &#123;<br>    <span class="hljs-comment">/// 声明一个number变量</span><br>    <span class="hljs-keyword">var</span> number: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() &#123;<br>        <span class="hljs-comment">/// 初始化完成之前给number赋值</span><br>        number <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Say Hello&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subclass</span>: <span class="hljs-title class_ inherited__">SuperClass</span> &#123;<br>    <span class="hljs-comment">/// 声明一个变量numberStr</span><br>    <span class="hljs-keyword">var</span> numberStr: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">word</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-comment">/// 初始化之前完成赋值</span><br>        numberStr <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span><br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()<br>        <span class="hljs-comment">/// 初始化完成之后修改父类的变量值</span><br>        number <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(name)</span> Say <span class="hljs-subst">\(word)</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><em>在子类的构造方法中改变父类的变量值，需要父类初始化完成之后才可以更改，需要注意的是<strong>如果在这个构造方法中还需要给自己的变量赋值，则需要放在父类初始化完成之前。</strong></em><h3 id="UIViewController子类构造方法的重写与重载"><a href="#UIViewController子类构造方法的重写与重载" class="headerlink" title="UIViewController子类构造方法的重写与重载"></a>UIViewController子类构造方法的重写与重载</h3></li><li>UIViewController子类构造方法的重写、重载和NSObject子类的重写、重载基本上相同，但是有一些需要注意的地方。<br>先看以下代码:<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_ inherited__">UIViewController</span> &#123;<br>    <span class="hljs-comment">/// 重写父类的init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)方法</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">nibName</span> <span class="hljs-params">nibNameOrNil</span>: <span class="hljs-type">String</span>?, <span class="hljs-params">bundle</span> <span class="hljs-params">nibBundleOrNil</span>: <span class="hljs-type">Bundle</span>?) &#123;<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(nibName: nibNameOrNil, bundle: nibBundleOrNil)<br>    &#125;<br>    <br>    <span class="hljs-comment">/// 重载父类的init()</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(nibName: <span class="hljs-literal">nil</span>, bundle: <span class="hljs-literal">nil</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init?</span>(<span class="hljs-params">coder</span> <span class="hljs-params">aDecoder</span>: <span class="hljs-type">NSCoder</span>) &#123;<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(coder: aDecoder)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>上面代码重写和重载了父类的构造方法，大家有没有发现重载父类方法的时候<code>super</code>调用的是<code>init(nibName:  nibName,  bundle: bundle)</code>方法?这是为什么呢？ 苹果官方是这么说的：<blockquote><p>The designated initializer. If you subclass UIViewController, you must call the super implementation of this<br>method, even if you aren’t using a NIB.  (As a convenience, the default init method will do this for you,<br>and specify nil for both of this methods arguments.) In the specified NIB, the File’s Owner proxy should<br>have its class set to your view controller subclass, with the view outlet connected to the main view. If you<br>invoke this method with a nil nib name, then this class’ -loadView method will attempt to load a NIB whose<br>name is the same as your view controller’s class. If no such NIB in fact exists then you must either call<br>-setView: before -view is invoked, or override the -loadView method to set up your views programatically.<br><code>public init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)</code></p></blockquote></li></ul><p>这段话的大体意思就是VC的<code>init()</code>是一个<em>Convenience</em>类型的构造方法，它会帮你把<code>public init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)</code>方法的两个参数都设置成nil。也就是说，如果你要重载UIViewController的<code>init()</code>方法，就需要手动将上面方法的两个参数置为<code>nil</code>。修改后<code>init()</code>重载的代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_ inherited__">UIViewController</span> &#123; <br>    <span class="hljs-comment">/// 便利构造方法</span><br>    <span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-comment">/// 根据Swift构造方法的特点，如果子类没有定义任何*Designated*类型的构造方法，则默认继承父类所有的*Designated*构造方法。</span><br>        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(nibName: <span class="hljs-literal">nil</span>, bundle: <span class="hljs-literal">nil</span>)<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><br>当然，还可以这么写：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_ inherited__">UIViewController</span> &#123;<br>    <span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-comment">/// 其实和上面的原理是一样的，UIViewController的init()方法把init(nibName: nib, bundle: bundle)的两个参数默认设置成了nil, 当然，这样看起来简洁一些</span><br>        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>OK，说完重载再回过头来说一下构造方法的重写，看下面代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_ inherited__">UIViewController</span> &#123;<br><span class="hljs-comment">/// 重写方法</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">nibName</span> <span class="hljs-params">nibNameOrNil</span>: <span class="hljs-type">String</span>?, <span class="hljs-params">bundle</span> <span class="hljs-params">nibBundleOrNil</span>: <span class="hljs-type">Bundle</span>?) &#123;<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(nibName: nibNameOrNil, bundle: nibBundleOrNil)<br>    &#125;<br>    <span class="hljs-comment">/// UIViewController中标记子类必须要实现的方法</span><br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init?</span>(<span class="hljs-params">coder</span> <span class="hljs-params">aDecoder</span>: <span class="hljs-type">NSCoder</span>) &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;init(coder:) has not been implemented&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>上面代码重写了UIViewController的<code>init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)</code>方法，编译器没有报错，运行没有问题，那么这个就可以跳过了。等等，下面的<code>required init?(coder aDecoder: NSCoder)</code>方法是什么鬼啊？Ok，先来说一下<code>required</code>这个修饰符，<code>required</code>修饰的方法要求子类<strong>必须实现</strong>，如果子类不实现，编译是不会通过的。那么问题又来了，我们平常用<code>ViewController</code>的时候也没有实现这个方法啊，程序跑的也很欢快啊，这是怎么回事呢？因为Swift构造方法的特点之一就是：<strong>“如果子类没有定义任何 </strong>Designated<strong> 类型的构造方法，则默认继承父类所有的 </strong>Designated<strong> 构造方法”</strong>。这下就明了吧，不是子类没有实现，只不过是继承了父类的实现罢了。那么接下来就要说一下UIView的构造方法了。再等等，可是为什么<strong>重写了方法</strong>之后就需要子类来实现了呢？答案还是在Swift构造方法的特点里：<strong>如果子类重写了父类的某一构造方法，则默认不在继承父类所有的构造方法。对于Designated类型的构造方法，子类重写了哪些，哪些才能够被使用。对于Convenienve类型的构造方法，需要在子类的重写方法中调用其依赖的父类Designated构造方法，代码如下:</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span>: <span class="hljs-title class_ inherited__">NSObject</span> &#123;<br>    <span class="hljs-comment">/// 父类convenience方法依赖的designated方法</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">word</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()<br>    &#125;<br>    <br>    <span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">word</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(name: <span class="hljs-string">&quot;wangzh&quot;</span>, word: word)<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span>: <span class="hljs-title class_ inherited__">SuperClass</span> &#123;<br>   <br>    <span class="hljs-comment">/// 重写父类的convenience方法</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">word</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-comment">/// 调用父类convenience依赖的designed方法</span><br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(name: <span class="hljs-string">&quot;哈哈&quot;</span>, word: <span class="hljs-string">&quot;ha&quot;</span>)<br>        <br>        <span class="hljs-comment">/// 这种调用是不会被编译通过的</span><br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(word: word)<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">test</span>() &#123;<br>        <span class="hljs-keyword">let</span> subClass <span class="hljs-operator">=</span> <span class="hljs-type">SubClass</span>.<span class="hljs-keyword">init</span>(word: <span class="hljs-string">&quot;哈哈&quot;</span>)<br>        <span class="hljs-built_in">print</span>(subClass)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="UIView子类构造方法的重写与重载"><a href="#UIView子类构造方法的重写与重载" class="headerlink" title="UIView子类构造方法的重写与重载"></a>UIView子类构造方法的重写与重载</h3><blockquote><p>UIView的构造方法其实就和UIViewController里面的差不多。可以这么说，UIKit里面构造方法的重写和重载都和上面说的UiViewController的差不多，这里就不多赘述了。</p></blockquote><h2 id="感谢："><a href="#感谢：" class="headerlink" title="感谢："></a>感谢：</h2><p><a href="https://yq.aliyun.com/articles/39484">珲少</a><br>分享的文章</p><p>原创作品，转载请注明出处：<a href="https://zhihaoo.wang">https://zhihaoo.wang</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;构造方法是一个类创建对象最先也是必须调用的方法, 在OC中, 我们更习惯称这类方法为初始化方法. OC中的初始化方法与普通方法相比,并没有太严格的分界除了要以init开头. 在Swift语言体系中，构造方法与普通的方法分界十分严格，从格式写法上就有</summary>
      
    
    
    
    <category term="iOS开发" scheme="https://zhihaoo.wang/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Swift" scheme="https://zhihaoo.wang/tags/Swift/"/>
    
  </entry>
  
</feed>
